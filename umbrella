#!/bin/bash
# Usage:
#   Single domain mode:
#     umbrella -d domain.com [-o output.txt] [-c config.yaml] [-t token]
#
#   Multiple domains (list) mode:
#     umbrella -l domains.txt [-c config.yaml] [-t token]
#
#   In list mode, each domainâ€™s results are saved in a file named <domain>.txt.
#
# The token (UUID format) can be directly supplied with -t/--token.
# If not, the script checks for the UMBRELLA_TOKEN env variable,
# or loads it from a config file (searched in the order: -c flag, ./config.yaml,
# then $HOME/.config/umbrella/config.yaml).

# Parse command-line options using GNU getopt
OPTIONS=$(getopt -o d:o:c:t:l:h -l domain:,output:,config:,token:,list:,help -- "$@")
if [ $? -ne 0 ]; then
    echo "Error: Incorrect options provided." >&2
    exit 1
fi
eval set -- "$OPTIONS"

# Initialize variables
DOMAIN=""
OUTPUT_FILE=""
CONFIG_FILE=""
TOKEN=""
LIST_FILE=""

# Process options
while true; do
    case "$1" in
        -d|--domain)
            DOMAIN="$2"
            shift 2
            ;;
        -o|--output)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        -c|--config)
            CONFIG_FILE="$2"
            shift 2
            ;;
        -t|--token)
            TOKEN="$2"
            shift 2
            ;;
        -l|--list)
            LIST_FILE="$2"
            shift 2
            ;;
        -h|--help|-hh)
            echo "Usage:"
            echo "  Single domain mode:"
            echo "    $0 -d domain.com [-o output.txt] [-c config.yaml] [-t token]"
            echo "  Multiple domains mode:"
            echo "    $0 -l domains.txt [-c config.yaml] [-t token]"
            exit 0
            ;;
        --)
            shift
            break
            ;;
        *)
            break
            ;;
    esac
done

# Validate that either a domain or a list is provided (but not both)
if [ -n "$DOMAIN" ] && [ -n "$LIST_FILE" ]; then
    echo "Error: Please specify either a single domain (-d) or a list file (-l), not both." >&2
    exit 1
fi
if [ -z "$DOMAIN" ] && [ -z "$LIST_FILE" ]; then
    echo "Error: You must specify either a single domain (-d) or a list file (-l)." >&2
    exit 1
fi

# Resolve the API token: If not provided via -t, check env variable UMBRELLA_TOKEN, then config file.
if [ -z "$TOKEN" ]; then
    if [ -n "$UMBRELLA_TOKEN" ]; then
        TOKEN="$UMBRELLA_TOKEN"
    else
        # Determine the config file location
        if [ -n "$CONFIG_FILE" ]; then
            if [ ! -f "$CONFIG_FILE" ]; then
                echo "Error: Config file not found at $CONFIG_FILE" >&2
                exit 1
            fi
        else
            if [ -f "./config.yaml" ]; then
                CONFIG_FILE="./config.yaml"
            elif [ -f "${HOME}/.config/umbrella/config.yaml" ]; then
                CONFIG_FILE="${HOME}/.config/umbrella/config.yaml"
            else
                echo "Error: Config file not found. Provide one via -c, or set UMBRELLA_TOKEN, or supply token via -t." >&2
                exit 1
            fi
        fi

        # Ensure yq is installed
        if ! command -v yq &> /dev/null; then
            echo "Error: yq is required but not installed." >&2
            exit 1
        fi

        # Attempt to extract the token using yq (supporting both v4 and v3 syntax)
        TOKEN=$(yq e '.token[0]' "$CONFIG_FILE" 2>/dev/null)
        if [ -z "$TOKEN" ] || [ "$TOKEN" == "null" ]; then
            TOKEN=$(yq e '.token' "$CONFIG_FILE" 2>/dev/null)
        fi
        if [ -z "$TOKEN" ] || [ "$TOKEN" == "null" ]; then
            TOKEN=$(yq r "$CONFIG_FILE" "token[0]" 2>/dev/null)
            if [ -z "$TOKEN" ] || [ "$TOKEN" == "null" ]; then
                TOKEN=$(yq r "$CONFIG_FILE" "token" 2>/dev/null)
            fi
        fi
        if [ -z "$TOKEN" ] || [ "$TOKEN" == "null" ]; then
            echo "Error: API token not found in config file." >&2
            exit 1
        fi
    fi
fi

# Function to query subdomains for a given domain and output results.
# Results are written to the output file if specified; otherwise, printed to STDOUT.
query_domain() {
    local d="$1"
    local out_file="$2"
    local OFFSET=""
    local LIMIT=100

    # If an output file is specified, clear it first.
    if [ -n "$out_file" ]; then
        > "$out_file"
    fi

    while true; do
        if [ -z "$OFFSET" ]; then
            URL="https://investigate.api.umbrella.com/subdomains/${d}?limit=${LIMIT}"
        else
            URL="https://investigate.api.umbrella.com/subdomains/${d}?limit=${LIMIT}&offsetName=${OFFSET}"
        fi

        RESPONSE=$(curl -s -L --request GET --url "$URL" \
            --header "Accept: application/json" \
            --header "Authorization: Bearer ${TOKEN}")

        # Extract only subdomain names using jq.
        NAMES=$(echo "$RESPONSE" | jq -r '.[].name')
        COUNT=$(echo "$NAMES" | wc -l)

        if [ -n "$out_file" ]; then
            echo "$NAMES" >> "$out_file"
        else
            echo "$NAMES"
        fi

        # If fewer than LIMIT results, we've reached the end.
        if [ "$COUNT" -lt "$LIMIT" ]; then
            break
        fi

        # Use the last subdomain as the offset for the next call.
        OFFSET=$(echo "$NAMES" | tail -n 1)
        sleep 1
    done
}

# Main logic:
# If list mode is used, iterate over each non-empty, non-comment line in the file.
if [ -n "$LIST_FILE" ]; then
    if [ ! -f "$LIST_FILE" ]; then
        echo "Error: List file not found at $LIST_FILE" >&2
        exit 1
    fi
    while IFS= read -r line || [ -n "$line" ]; do
        domain_entry=$(echo "$line" | xargs)  # trim whitespace
        # Skip empty lines or those starting with "#"
        if [ -z "$domain_entry" ] || [[ "$domain_entry" == \#* ]]; then
            continue
        fi
        # For each domain, output is saved as <domain>.txt in the current directory.
        output_file="${domain_entry}.txt"
        query_domain "$domain_entry" "$output_file"
    done < "$LIST_FILE"
else
    # Single domain mode. If an output file is provided via -o, use it; otherwise, print to STDOUT.
    query_domain "$DOMAIN" "$OUTPUT_FILE"
fi
